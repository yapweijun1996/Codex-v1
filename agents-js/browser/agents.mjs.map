{
  "version": 3,
  "sources": ["../utils/emitter.js", "../utils/context-manager.js", "../utils/mcp-adapter.js", "../utils/self-heal.js", "../agents.js"],
  "sourcesContent": ["// Minimal EventEmitter for Browser ESM.\n//\n// This is intentionally tiny and dependency-free so browser mode stays vanilla.\n\nexport class EventEmitter {\n    constructor() {\n        this._listeners = new Map();\n    }\n\n    on(event, fn) {\n        if (!this._listeners.has(event)) this._listeners.set(event, []);\n        this._listeners.get(event).push(fn);\n        return this;\n    }\n\n    once(event, fn) {\n        const wrapper = (...args) => {\n            this.off(event, wrapper);\n            fn(...args);\n        };\n        return this.on(event, wrapper);\n    }\n\n    off(event, fn) {\n        const listeners = this._listeners.get(event);\n        if (!listeners) return this;\n        this._listeners.set(event, listeners.filter((l) => l !== fn));\n        return this;\n    }\n\n    removeListener(event, fn) {\n        return this.off(event, fn);\n    }\n\n    removeAllListeners(event) {\n        if (event) this._listeners.delete(event);\n        else this._listeners.clear();\n        return this;\n    }\n\n    emit(event, ...args) {\n        const listeners = this._listeners.get(event);\n        if (!listeners || listeners.length === 0) return false;\n        for (const fn of listeners.slice()) {\n            try {\n                fn(...args);\n            } catch (err) {\n                // Avoid breaking the emitter loop.\n                console.error(`Error in listener for event \"${event}\":`, err);\n            }\n        }\n        return true;\n    }\n}\n", "function estimateTokensForMessage(msg) {\n    if (!msg || typeof msg !== 'object') return 0;\n    let chars = 0;\n\n    if (typeof msg.role === 'string') chars += msg.role.length + 8;\n    if (typeof msg.name === 'string') chars += msg.name.length + 8;\n\n    if (typeof msg.content === 'string') {\n        chars += msg.content.length;\n    } else if (msg.content != null) {\n        try {\n            chars += JSON.stringify(msg.content).length;\n        } catch {\n            chars += 0;\n        }\n    }\n\n    if (Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {\n        try {\n            chars += JSON.stringify(msg.tool_calls).length;\n        } catch {\n            chars += 0;\n        }\n    }\n\n    if (typeof msg.tool_call_id === 'string') chars += msg.tool_call_id.length + 8;\n\n    return Math.ceil(chars / 4);\n}\n\nfunction estimateTokens(history) {\n    if (!Array.isArray(history)) return 0;\n    let tokens = 0;\n    for (const msg of history) tokens += estimateTokensForMessage(msg);\n    return tokens;\n}\n\nfunction getToolCallIdsFromAssistantMessage(msg) {\n    if (!msg || msg.role !== 'assistant' || !Array.isArray(msg.tool_calls)) return [];\n    return msg.tool_calls\n        .map(tc => (tc && typeof tc.id === 'string') ? tc.id : null)\n        .filter(Boolean);\n}\n\nfunction buildToolCallMaps(history) {\n    const callIdToAssistantIndex = new Map();\n    const callIdToResultIndices = new Map();\n\n    for (let i = 0; i < history.length; i++) {\n        const msg = history[i];\n        if (!msg || typeof msg !== 'object') continue;\n\n        if (msg.role === 'assistant' && Array.isArray(msg.tool_calls)) {\n            for (const tc of msg.tool_calls) {\n                if (!tc || typeof tc.id !== 'string') continue;\n                // Prefer first occurrence (earliest) for stability.\n                if (!callIdToAssistantIndex.has(tc.id)) callIdToAssistantIndex.set(tc.id, i);\n            }\n        }\n\n        if ((msg.role === 'system' || msg.role === 'tool') && typeof msg.tool_call_id === 'string') {\n            const list = callIdToResultIndices.get(msg.tool_call_id) || [];\n            list.push(i);\n            callIdToResultIndices.set(msg.tool_call_id, list);\n        }\n    }\n\n    return { callIdToAssistantIndex, callIdToResultIndices };\n}\n\nfunction enforceToolIntegrity(selectedIndices, history) {\n    const kept = new Set(selectedIndices);\n    const { callIdToAssistantIndex, callIdToResultIndices } = buildToolCallMaps(history);\n\n    // 1) Drop tool results without their originating assistant tool call.\n    for (const [callId, resIdxs] of callIdToResultIndices.entries()) {\n        const assistantIdx = callIdToAssistantIndex.get(callId);\n        const assistantKept = typeof assistantIdx === 'number' && kept.has(assistantIdx);\n        if (!assistantKept) {\n            for (const idx of resIdxs) kept.delete(idx);\n        }\n    }\n\n    // 2) Drop assistant tool calls unless ALL expected tool results are kept.\n    for (const idx of Array.from(kept).sort((a, b) => a - b)) {\n        const msg = history[idx];\n        const callIds = getToolCallIdsFromAssistantMessage(msg);\n        if (callIds.length === 0) continue;\n\n        let ok = true;\n        for (const callId of callIds) {\n            const resIdxs = callIdToResultIndices.get(callId) || [];\n            if (resIdxs.length === 0) {\n                // If we can't find results at all, keep behavior conservative: treat as incomplete.\n                ok = false;\n                break;\n            }\n            if (!resIdxs.every(rIdx => kept.has(rIdx))) {\n                ok = false;\n                break;\n            }\n        }\n\n        if (!ok) {\n            kept.delete(idx);\n            // Also drop any already-kept results for its callIds.\n            for (const callId of callIds) {\n                const resIdxs = callIdToResultIndices.get(callId) || [];\n                for (const rIdx of resIdxs) kept.delete(rIdx);\n            }\n        }\n    }\n\n    return Array.from(kept).sort((a, b) => a - b);\n}\n\nfunction maybeTruncateLargeToolOutputs(history, { maxToolOutputChars } = {}) {\n    if (!maxToolOutputChars || !Array.isArray(history)) return history;\n    const cap = Number(maxToolOutputChars);\n    if (!Number.isFinite(cap) || cap <= 0) return history;\n\n    return history.map((msg) => {\n        if (!msg || typeof msg !== 'object') return msg;\n        if (msg.role !== 'system' && msg.role !== 'tool') return msg;\n        if (typeof msg.content !== 'string') return msg;\n        if (msg.content.length <= cap) return msg;\n\n        const replacement = {\n            _truncated: true,\n            note: 'tool output omitted',\n            originalChars: msg.content.length,\n        };\n\n        return {\n            ...msg,\n            content: JSON.stringify(replacement),\n        };\n    });\n}\n\nclass ContextManager {\n    constructor(options = {}) {\n        this.defaults = {\n            maxMessages: 16,\n            preserveHeadMessages: 2,\n            maxEstimatedTokens: undefined,\n            maxToolOutputChars: undefined,\n            ...options,\n        };\n    }\n\n    process(history, options = {}) {\n        const cfg = { ...this.defaults, ...options };\n        const original = Array.isArray(history) ? history : [];\n\n        const maxMessages = Math.max(1, Number(cfg.maxMessages) || 16);\n        const preserveHeadMessages = Math.max(0, Math.min(maxMessages, Number(cfg.preserveHeadMessages) || 0));\n\n        const headCount = Math.min(preserveHeadMessages, original.length, maxMessages);\n        let selected;\n\n        if (original.length <= maxMessages) {\n            selected = Array.from({ length: original.length }, (_, i) => i);\n        } else {\n            const tailCount = Math.max(0, maxMessages - headCount);\n            const indices = new Set();\n            for (let i = 0; i < headCount; i++) indices.add(i);\n            const tailStart = Math.max(headCount, original.length - tailCount);\n            for (let i = tailStart; i < original.length; i++) indices.add(i);\n            selected = Array.from(indices).sort((a, b) => a - b);\n        }\n\n        selected = enforceToolIntegrity(selected, original);\n\n        // Token-driven trimming: drop oldest non-head messages until under limit.\n        const maxEstimatedTokens = cfg.maxEstimatedTokens;\n        if (Number.isFinite(Number(maxEstimatedTokens))) {\n            const cap = Number(maxEstimatedTokens);\n\n            // Keep dropping from just after the head, respecting tool integrity.\n            // Stop when nothing removable remains.\n            while (true) {\n                const current = selected.map(i => original[i]);\n                const currentTokens = estimateTokens(current);\n                if (currentTokens <= cap) break;\n\n                const removable = selected.filter(i => i >= headCount);\n                if (removable.length === 0) break;\n\n                const dropIdx = removable[0];\n                selected = selected.filter(i => i !== dropIdx);\n                selected = enforceToolIntegrity(selected, original);\n            }\n        }\n\n        let outHistory = selected.map(i => original[i]);\n        outHistory = maybeTruncateLargeToolOutputs(outHistory, cfg);\n\n        return {\n            history: outHistory,\n            meta: {\n                dropped: Math.max(0, original.length - outHistory.length),\n                estimatedTokens: estimateTokens(outHistory),\n            },\n        };\n    }\n}\n\nmodule.exports = { ContextManager, estimateTokens };\n", "// MCP adapter helpers (pure JS, works in Node + Browser).\n//\n// Reference: codex-main/codex-rs/mcp-types/src/lib.rs\n// - Tool.inputSchema\n// - CallToolResult: { content: ContentBlock[], isError?: boolean, structuredContent?: any }\n\nfunction toMcpInputSchema(parameters) {\n    const p = parameters && typeof parameters === 'object' ? parameters : null;\n    const schema = {\n        type: 'object',\n        properties: {},\n    };\n\n    if (!p) return schema;\n\n    // Our existing tool shape uses `parameters` (OpenAI-like) with JSON Schema.\n    if (p.type) schema.type = p.type;\n    if (p.properties && typeof p.properties === 'object') schema.properties = p.properties;\n    if (Array.isArray(p.required)) schema.required = p.required;\n    if (p.description) schema.description = p.description;\n    if (p.title) schema.title = p.title;\n\n    return schema;\n}\n\nfunction _isContentBlockArray(content) {\n    return Array.isArray(content) && content.every((b) => b && typeof b === 'object' && typeof b.type === 'string');\n}\n\nfunction toMcpCallToolResult(output, { isError } = {}) {\n    // If the tool already returns MCP style, keep it (best-effort normalize).\n    if (output && typeof output === 'object' && !Array.isArray(output)) {\n        const hasContent = _isContentBlockArray(output.content);\n        const normalized = {\n            content: hasContent ? output.content : undefined,\n            structuredContent: output.structuredContent,\n            isError: (typeof output.isError === 'boolean') ? output.isError : undefined,\n        };\n\n        if (!normalized.content) {\n            // Fallback: stringify the object into a text block.\n            normalized.structuredContent = (normalized.structuredContent === undefined) ? output : normalized.structuredContent;\n            normalized.content = [{ type: 'text', text: JSON.stringify(output, null, 2) }];\n        }\n\n        if (typeof isError === 'boolean') normalized.isError = isError;\n        return normalized;\n    }\n\n    if (typeof output === 'string') {\n        return {\n            content: [{ type: 'text', text: output }],\n            ...(typeof isError === 'boolean' ? { isError } : null),\n        };\n    }\n\n    // numbers/booleans/null/arrays => stringify into text, preserve structuredContent.\n    return {\n        content: [{ type: 'text', text: JSON.stringify(output, null, 2) }],\n        structuredContent: output,\n        ...(typeof isError === 'boolean' ? { isError } : null),\n    };\n}\n\nmodule.exports = {\n    toMcpInputSchema,\n    toMcpCallToolResult,\n};\n", "// Utilities for self-healing and loop detection.\n// Keep this module environment-agnostic (no Node-only deps).\n\nconst DEFAULT_TOOL_TIMEOUT_MS = 30_000;\nconst DEFAULT_REPEAT_FAILURE_THRESHOLD = 2;\nconst DEFAULT_LOOP_FINGERPRINT_THRESHOLD = 3;\n\nfunction isPlainObject(value) {\n    if (!value || typeof value !== 'object') return false;\n    const proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\n\nfunction stableStringify(value) {\n    const seen = new WeakSet();\n\n    function normalize(v) {\n        if (v === null) return null;\n        const t = typeof v;\n        if (t === 'string' || t === 'number' || t === 'boolean') return v;\n        if (t === 'bigint') return String(v);\n        if (t === 'undefined') return null;\n        if (t === 'function') return '[Function]';\n        if (t === 'symbol') return String(v);\n\n        if (t === 'object') {\n            if (seen.has(v)) return '[Circular]';\n            seen.add(v);\n\n            if (Array.isArray(v)) return v.map(normalize);\n\n            if (v instanceof Date) return v.toISOString();\n            if (v instanceof Error) {\n                return {\n                    name: v.name,\n                    message: v.message,\n                };\n            }\n\n            if (!isPlainObject(v)) {\n                // Best-effort: preserve enumerable keys only.\n                const out = {};\n                for (const k of Object.keys(v).sort()) {\n                    out[k] = normalize(v[k]);\n                }\n                return out;\n            }\n\n            const out = {};\n            for (const k of Object.keys(v).sort()) {\n                out[k] = normalize(v[k]);\n            }\n            return out;\n        }\n\n        return String(v);\n    }\n\n    try {\n        return JSON.stringify(normalize(value));\n    } catch {\n        // Last resort: never throw from stableStringify.\n        return 'null';\n    }\n}\n\nfunction safeJsonStringify(value) {\n    // Prefer native JSON for compactness, but fall back to stableStringify on circulars.\n    try {\n        return JSON.stringify(value === undefined ? null : value);\n    } catch {\n        return stableStringify(value);\n    }\n}\n\nfunction isRateLimitLike(input) {\n    const text = String(input || '').toLowerCase();\n    if (!text) return false;\n    return (\n        text.includes('too many requests') ||\n        text.includes('rate limit') ||\n        text.includes('ratelimit') ||\n        text.includes('status: 429') ||\n        text.includes('http 429') ||\n        text.includes(' 429')\n    );\n}\n\n// Small deterministic hash (djb2) to keep fingerprints compact.\nfunction hashString(input) {\n    const str = String(input || '');\n    let hash = 5381;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) + hash) ^ str.charCodeAt(i);\n    }\n    // Convert to unsigned 32-bit then base36.\n    return (hash >>> 0).toString(36);\n}\n\nfunction makeFailureFingerprint(toolName, failureType, args) {\n    const argsStable = stableStringify(args);\n    return `${toolName}:${String(failureType || 'unknown')}:${hashString(argsStable)}`;\n}\n\nmodule.exports = {\n    DEFAULT_TOOL_TIMEOUT_MS,\n    DEFAULT_REPEAT_FAILURE_THRESHOLD,\n    DEFAULT_LOOP_FINGERPRINT_THRESHOLD,\n    stableStringify,\n    safeJsonStringify,\n    isRateLimitLike,\n    hashString,\n    makeFailureFingerprint,\n};\n", "\r\nconst { EventEmitter } = require('events');\nconst { ContextManager } = require('./utils/context-manager');\nconst { toMcpCallToolResult } = require('./utils/mcp-adapter');\nconst {\n    DEFAULT_TOOL_TIMEOUT_MS,\n    DEFAULT_LOOP_FINGERPRINT_THRESHOLD,\n    makeFailureFingerprint,\n    stableStringify,\n    safeJsonStringify,\n    isRateLimitLike,\n} = require('./utils/self-heal');\n\nfunction _createAsyncEventQueue() {\n    const queue = [];\n    const waiters = [];\n    let closed = false;\n\n    const notify = () => {\n        while (waiters.length > 0) {\n            const w = waiters.shift();\n            if (typeof w === 'function') w();\n        }\n    };\n\n    return {\n        push: (value) => {\n            if (closed) return;\n            queue.push(value);\n            notify();\n        },\n        close: () => {\n            if (closed) return;\n            closed = true;\n            notify();\n        },\n        async *iterate() {\n            while (true) {\n                if (queue.length > 0) {\n                    yield queue.shift();\n                    continue;\n                }\n                if (closed) return;\n                await new Promise((resolve) => waiters.push(resolve));\n            }\n        },\n    };\n}\n\r\n/**\r\n * agents.js - A minimal agentic framework inspired by Codex ReAct logic.\r\n * \r\n * Core concepts ported from Codex (Rust):\r\n * 1. Session/Context: Manages conversation history (`history`).\r\n * 2. Submission Loop: The `run()` method acts as the main drive loop.\r\n * 3. ToolRouter: A registry (`toolRegistry`) to dispatch function calls.\r\n * 4. Turn Logic: The `_step()` method mimics `run_sampling_request`.\r\n * \r\n * Enhanced with EventEmitter for streaming support.\r\n */\r\n\r\nclass Agent extends EventEmitter {\n    /**\r\n     * @param {Object} config\r\n     * @param {Object} config.llm - The LLM client interface (must have `chat()` method).\r\n     * @param {Array} config.tools - List of executable tool definitions.\r\n     * @param {String} config.systemPrompt - The base instructions (Codex: `BaseInstructions`).\r\n     */\r\n    constructor({ llm, tools = [], systemPrompt = \"You are a helpful AI assistant.\", toolTimeoutMs } = {}) {\n        super(); // Initialize EventEmitter\n        this.llm = llm;\n        this.tools = this._registerTools(tools);\n        this.systemPrompt = systemPrompt;\n        this.history = []; // Analogous to Codex `session.history`\n        this.status = 'idle'; // local AgentStatus\n\n        // Tool execution timeout (best-effort). Note: generic JS Promises cannot be force-cancelled.\n        // For tools that support cancellation internally (e.g. AbortController), they should handle it.\n        this.toolTimeoutMs =\n            (typeof toolTimeoutMs === 'number' && Number.isFinite(toolTimeoutMs) && toolTimeoutMs > 0)\n                ? toolTimeoutMs\n                : DEFAULT_TOOL_TIMEOUT_MS;\n\n        // Tracks consecutive tool failures to enable self-healing hints.\n        // Map: toolName -> { count: number, fingerprint: string }\n        this._toolFailureStreak = new Map();\n\n        // Context manager trims the history sent to the LLM.\n        // IMPORTANT: We keep full `this.history` for traceability, but only send a pruned copy.\n        this.contextManager = new ContextManager();\n    }\n\r\n    /**\r\n     * Maps tool definitions to a quick lookup registry.\r\n     */\r\n    _registerTools(tools) {\n        const registry = {};\r\n        for (const tool of tools) {\r\n            registry[tool.name] = tool;\r\n        }\r\n        return registry;\r\n    }\n\n    _buildSyntheticToolPlan(toolCalls) {\n        const lines = [];\n        lines.push('Thought: I need to use tools to gather required information before answering.');\n        lines.push('Plan:');\n        toolCalls.forEach((call, idx) => {\n            let argsPreview = '';\n            try {\n                const args = typeof call.arguments === 'string' ? JSON.parse(call.arguments) : (call.arguments || {});\n                const compact = JSON.stringify(args);\n                argsPreview = compact && compact !== '{}' ? ` with ${compact}` : '';\n            } catch {\n                argsPreview = '';\n            }\n            lines.push(`${idx + 1}. Call ${call.name}${argsPreview}.`);\n        });\n        lines.push('Action: Calling tool(s) now.');\n        return lines.join('\\n') + '\\n';\n    }\n\r\n    /**\r\n     * High-level entry point. Submits a user message and runs the ReAct loop.\r\n     * Analogous to `codex.submit(Op::UserTurn)` and `submission_loop`.\r\n     * \r\n     * @param {String} userInput - The user input.\r\n     * @returns {Promise<String>} - The final assistant response.\r\n     */\r\n    /**\r\n     * High-level entry point. Submits a user message and runs the ReAct loop.\r\n     * Analogous to `codex.submit(Op::UserTurn)` and `submission_loop`.\r\n     * \r\n     * @param {String} userInput - The user input.\r\n     * @returns {Promise<String>} - The final assistant response.\r\n     */\r\n    async run(userInput) {\n        this.status = 'running';\n        console.log(`\\n--- [Agent] Starting Turn: \"${userInput}\" ---`);\n\n        // Reset per-turn error tracking.\n        this._toolFailureStreak = new Map();\n\r\n        // Emit start and turn_started events (Codex: TurnStarted)\r\n        this.emit('start', { message: userInput });\r\n        this.emit('turn_started', {\r\n            message: userInput,\r\n            timestamp: new Date().toISOString()\r\n        });\r\n\r\n        // 1. Inject User Input into History\r\n        this.history.push({ role: 'user', content: userInput });\r\n\r\n        let finalResponseText = \"\";\r\n        let turnCount = 0;\r\n        const MAX_TURNS = 10;\r\n\r\n        // 2. The Reasoning Loop (codex: `run_turn` -> loop `run_sampling_request`)\r\n        while (turnCount < MAX_TURNS) {\r\n            turnCount++;\r\n            console.log(`[Agent] Step ${turnCount}: Thinking...`);\r\n\r\n            // Emit thinking event\r\n            this.emit('thinking', { step: turnCount });\r\n\r\n            // 3. Call LLM with streaming (if available)\n            let currentStepResponse = { content: \"\", tool_calls: [] };\n\n            const pruned = this.contextManager.process(this.history);\n            const llmHistory = pruned.history;\n            if (pruned.meta && pruned.meta.dropped > 0) {\n                this.emit('context_truncated', {\n                    dropped: pruned.meta.dropped,\n                    estimatedTokens: pruned.meta.estimatedTokens,\n                    fullHistoryLength: this.history.length,\n                    sentHistoryLength: llmHistory.length,\n                });\n            }\n\r\n            if (typeof this.llm.chatStream === 'function') {\n                const stream = this.llm.chatStream(this.systemPrompt, llmHistory);\n\r\n                // Track if we've started an assistant message\r\n                let messageStarted = false;\r\n\r\n                for await (const chunk of stream) {\r\n                    if (chunk.type === 'text') {\r\n                        if (!messageStarted) {\r\n                            this.emit('assistant_message_started', { step: turnCount });\r\n                            messageStarted = true;\r\n                        }\r\n                        currentStepResponse.content += chunk.delta;\r\n\r\n                        // Codex: AgentMessageContentDelta\r\n                        this.emit('agent_message_content_delta', {\r\n                            delta: chunk.delta,\r\n                            step: turnCount\r\n                        });\r\n                    } else if (chunk.type === 'tool_calls') {\r\n                        currentStepResponse.tool_calls.push(...chunk.tool_calls);\r\n\r\n                        // Emit tool call event\r\n                        this.emit('tool_call', {\r\n                            tools: chunk.tool_calls.map(tc => tc.name),\r\n                            details: chunk.tool_calls\r\n                        });\r\n                    }\r\n                }\r\n            } else {\n                // Fallback to non-streaming if chatStream is missing\n                const response = await this.llm.chat(this.systemPrompt, llmHistory);\n                currentStepResponse = response;\n\r\n                if (response.content) {\r\n                    this.emit('agent_message_content_delta', {\r\n                        delta: response.content,\r\n                        step: turnCount\r\n                    });\r\n                }\r\n\r\n                if (response.tool_calls && response.tool_calls.length > 0) {\r\n                    this.emit('tool_call', {\r\n                        tools: response.tool_calls.map(tc => tc.name),\r\n                        details: response.tool_calls\r\n                    });\r\n                }\r\n            }\r\n\r\n            // 4. Check if LLM wants to call a tool\n            if (currentStepResponse.tool_calls && currentStepResponse.tool_calls.length > 0) {\n                // If the model returns only tool calls (no text), emit a small synthetic plan\n                // so users can see reasoning steps without injecting full skill docs.\n                if (!currentStepResponse.content) {\n                    const synthetic = this._buildSyntheticToolPlan(currentStepResponse.tool_calls);\n                    this.emit('assistant_message_started', { step: turnCount });\n                    this.emit('agent_message_content_delta', { delta: synthetic, step: turnCount });\n                    this.history.push({ role: 'assistant', content: synthetic });\n                }\n\n                // Add the assistant's \"thought\" (tool call request) to history\n                this.history.push({\n                    role: 'assistant',\n                    content: currentStepResponse.content || null,\n                    tool_calls: currentStepResponse.tool_calls\n                });\n\r\n                // 5. Execute Tools (codex: `ToolRuntime` / `drain_in_flight`)\r\n                const toolResults = await this._executeTools(currentStepResponse.tool_calls);\r\n\r\n                // 6. Feed results back to history\r\n                this.history.push(...toolResults);\r\n\r\n                // Loop continues to let LLM see the results and decide next step\r\n            } else {\r\n                // 7. No tool calls = Final Answer\r\n                console.log(`[Agent] Final Answer Generated.`);\r\n                this.history.push({ role: 'assistant', content: currentStepResponse.content });\r\n                finalResponseText = currentStepResponse.content;\r\n\r\n                // Emit response event\r\n                this.emit('response', { content: finalResponseText });\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.status = 'idle';\r\n\r\n        // Emit done and agent_turn_complete events (Codex: AgentTurnComplete)\r\n        const completionData = {\r\n            response: finalResponseText || \"Agent failed to produce a response within turn limit.\",\r\n            turnCount,\r\n            historyLength: this.history.length\r\n        };\r\n\r\n        this.emit('done', completionData);\r\n        this.emit('agent_turn_complete', completionData);\r\n\r\n        return finalResponseText || \"Agent failed to produce a response within turn limit.\";\r\n    }\r\n\r\n    /**\r\n     * Executors for the tools.\r\n     * Analogous to Codex `handlers` or `ToolCallRuntime`.\r\n     */\r\n    async _executeTools(toolCalls) {\n        const results = [];\n\r\n        // Parallel execution (Promise.all) mimicking Codex async task spawning\r\n        const promises = toolCalls.map(async (call) => {\n            const tool = this.tools[call.name];\n            if (!tool) {\n                let argsForFingerprint;\n                try {\n                    argsForFingerprint = typeof call.arguments === 'string' ? JSON.parse(call.arguments) : call.arguments;\n                } catch {\n                    argsForFingerprint = undefined;\n                }\n\n                const output = {\n                    error: 'Tool not found',\n                    tool: call.name,\n                    hint: \"Use list_available_skills to discover the correct tool, then read_skill_documentation before calling it.\",\n                };\n\n                this._recordToolFailure(call.name, 'tool_not_found', argsForFingerprint);\n\n                const wrapped = this._withSelfHealHint(call.name, output);\n                const mcpResult = toMcpCallToolResult(wrapped, { isError: true });\n\n                return {\n                    role: 'system',\n                    tool_call_id: call.id,\n                    name: call.name,\n                    content: safeJsonStringify(mcpResult),\n                };\n            }\n\n            try {\n                let args;\n                // Determine raw arguments (LLMs often return JSON string)\n                args = typeof call.arguments === 'string' ? JSON.parse(call.arguments) : call.arguments;\n\n                console.log(`  > Executing ${call.name} with args:`, args);\n\n                // Await key for async tools (e.g. fetch, file I/O), with a best-effort timeout.\n                const timed = await this._callToolWithTimeout(() => tool.func(args), this.toolTimeoutMs);\n                const rawOutput = timed.timedOut\n                    ? {\n                        error: 'Timeout',\n                        timeoutMs: this.toolTimeoutMs,\n                        message: `Tool execution exceeded ${this.toolTimeoutMs}ms`,\n                    }\n                    : timed.value;\n\n                // Normalize output for safe JSON.stringify/parse round-trip.\n                let output = (rawOutput === undefined) ? null : rawOutput;\n                let formatError = false;\n                if (!timed.timedOut) {\n                    try {\n                        JSON.stringify(output);\n                    } catch {\n                        formatError = true;\n                        // Replace with a safe, structured representation.\n                        try {\n                            output = JSON.parse(stableStringify(output));\n                        } catch {\n                            output = { error: 'Format Error', message: 'Tool output was not JSON serializable.' };\n                        }\n                    }\n                }\n\n                const failureType = timed.timedOut\n                    ? 'timeout'\n                    : (formatError ? 'format_error' : this._classifyToolFailure(call.name, output));\n                if (failureType) {\n                    this._recordToolFailure(call.name, failureType, args);\n                } else {\n                    this._clearToolFailure(call.name);\n                }\n\n                // Emit tool result event\n                this.emit('tool_result', {\n                    tool: call.name,\n                    args,\n                    result: output\n                });\n\n                const wrapped = this._withSelfHealHint(call.name, output);\n                const mcpResult = toMcpCallToolResult(wrapped, { isError: Boolean(failureType) });\n\n                return {\n                    role: 'system', // or 'tool' in OpenAI format\n                    tool_call_id: call.id,\n                    name: call.name,\n                    content: safeJsonStringify(mcpResult)\n                };\n            } catch (error) {\n                console.error(`  > Error executing ${call.name}:`, error);\n\r\n                // Emit error event\r\n                this.emit('tool_error', {\n                    tool: call.name,\n                    error: error.message\n                });\n\n                // Best-effort: attempt to include args in the fingerprint.\n                let argsForFingerprint;\n                try {\n                    argsForFingerprint = typeof call.arguments === 'string' ? JSON.parse(call.arguments) : call.arguments;\n                } catch {\n                    argsForFingerprint = undefined;\n                }\n\n                this._recordToolFailure(\n                    call.name,\n                    (() => {\n                        const msg = String(error && error.message ? error.message : error);\n                        if (this._isBrowserRuntime() && this._isBrowserEnvRestrictionLikeMessage(msg)) {\n                            return 'environment_restriction';\n                        }\n                        return isRateLimitLike(msg) ? 'rate_limited' : `exception:${msg}`;\n                    })(),\n                    argsForFingerprint\n                );\n\n                const output = {\n                    error: 'Tool execution failed',\n                    message: String(error && error.message ? error.message : error),\n                };\n\n                const wrapped = this._withSelfHealHint(call.name, output);\n                const mcpResult = toMcpCallToolResult(wrapped, { isError: true });\n\n                return {\n                    role: 'system',\n                    tool_call_id: call.id,\n                    name: call.name,\n                    content: safeJsonStringify(mcpResult)\n                };\n            }\n        });\n\r\n        return await Promise.all(promises);\n    }\n\n    /**\n     * Streaming interface for UI consumption.\n     *\n     * This is a compatibility wrapper around the existing EventEmitter-based streaming.\n     * It attaches listeners, calls `run(userInput)`, and yields normalized events via\n     * an AsyncIterator so UIs can do `for await...of`.\n     *\n     * @param {string} userInput\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal] - Best-effort cancellation.\n     */\n    async *runAsyncIterator(userInput, options = {}) {\n        const { signal } = options;\n        const q = _createAsyncEventQueue();\n\n        const on = (evt, fn) => this.on(evt, fn);\n        const off = (evt, fn) => {\n            if (typeof this.off === 'function') this.off(evt, fn);\n            else this.removeListener(evt, fn);\n        };\n\n        const handlers = {\n            start: (data) => q.push({ type: 'turn.started', input: data && data.message ? data.message : userInput }),\n            thinking: (data) => q.push({ type: 'thinking', step: data && data.step }),\n            context_truncated: (data) => q.push({ type: 'context.truncated', ...data }),\n            assistant_message_started: (data) => q.push({ type: 'assistant_message_started', ...data }),\n            agent_message_content_delta: (data) => q.push({ type: 'response.chunk', delta: data && data.delta ? data.delta : '', step: data && data.step }),\n            tool_call: (data) => q.push({ type: 'tool.call', tools: data && data.tools ? data.tools : [], details: data && data.details ? data.details : [] }),\n            tool_result: (data) => q.push({ type: 'tool.result', tool: data && data.tool, args: data && data.args, result: data && data.result }),\n            tool_error: (data) => q.push({ type: 'tool.error', tool: data && data.tool, error: data && data.error }),\n            done: (data) => {\n                q.push({\n                    type: 'turn.completed',\n                    finalResponse: data && typeof data.response === 'string' ? data.response : '',\n                    turnCount: data && data.turnCount,\n                    historyLength: data && data.historyLength,\n                });\n                q.close();\n            },\n        };\n\n        for (const [evt, fn] of Object.entries(handlers)) on(evt, fn);\n\n        let aborted = false;\n        const abortHandler = () => {\n            aborted = true;\n            q.push({ type: 'error', message: 'Aborted' });\n            q.close();\n        };\n        if (signal && typeof signal.addEventListener === 'function') {\n            if (signal.aborted) abortHandler();\n            else signal.addEventListener('abort', abortHandler, { once: true });\n        }\n\n        const runPromise = Promise.resolve()\n            .then(() => this.run(userInput))\n            .catch((err) => {\n                // If `run()` throws before emitting `done`, surface it as a terminal error.\n                const msg = err && err.message ? String(err.message) : String(err);\n                q.push({ type: 'error', message: msg });\n                q.close();\n                return null;\n            });\n\n        try {\n            for await (const ev of q.iterate()) {\n                yield ev;\n            }\n        } finally {\n            for (const [evt, fn] of Object.entries(handlers)) off(evt, fn);\n            if (signal && typeof signal.removeEventListener === 'function') {\n                signal.removeEventListener('abort', abortHandler);\n            }\n            // Ensure background run completes to avoid unhandled rejections.\n            await runPromise;\n            if (aborted) return;\n        }\n    }\n\n    _classifyToolFailure(toolName, output) {\n        // Best-effort heuristics:\n        // - { error: ... } => failure\n        // - run_command: non-zero exitCode => failure\n        if (output && typeof output === 'object') {\n            if (output.error) {\n                if (String(output.error).toLowerCase() === 'timeout') {\n                    return 'timeout';\n                }\n\n                if (\n                    output.status === 429 ||\n                    output.statusCode === 429 ||\n                    output.code === 429 ||\n                    isRateLimitLike(output.error) ||\n                    isRateLimitLike(output.message)\n                ) {\n                    return 'rate_limited';\n                }\n\n                // Browser-only: classify environment restrictions (CORS, blocked fetch) separately.\n                if (this._isBrowserRuntime()) {\n                    const err = String(output.error || '');\n                    const meta = [output.message, output.reason, output.detail, output.hint]\n                        .filter(Boolean)\n                        .map((v) => String(v))\n                        .join(' ');\n                    const combined = `${err} ${meta}`;\n                    if (\n                        String(output.platform || '').toLowerCase() === 'browser' ||\n                        err.toLowerCase() === 'environment restriction' ||\n                        this._isBrowserEnvRestrictionLikeMessage(combined)\n                    ) {\n                        return 'environment_restriction';\n                    }\n                }\n\n                if (toolName === 'run_command' && String(output.error).toLowerCase().includes('access denied')) {\n                    return 'access_denied';\n                }\n                return 'tool_error';\n            }\n\n            if (toolName === 'run_command' && typeof output.exitCode === 'number' && output.exitCode !== 0) {\n                return 'nonzero_exit';\n            }\n        }\n        return null;\n    }\n\n    _isBrowserRuntime() {\n        return typeof window !== 'undefined';\n    }\n\n    _isBrowserEnvRestrictionLikeMessage(message) {\n        const text = String(message || '').toLowerCase();\n        if (!text) return false;\n        return (\n            text.includes('cors') ||\n            text.includes('cross-origin') ||\n            text.includes('access-control-allow-origin') ||\n            text.includes('failed to fetch') ||\n            text.includes('networkerror when attempting to fetch') ||\n            text.includes('load failed') ||\n            text.includes('same origin') ||\n            text.includes('same-origin')\n        );\n    }\n\n    async _callToolWithTimeout(fn, timeoutMs) {\n        // `fn` should return a promise.\n        const ms = (typeof timeoutMs === 'number' && timeoutMs > 0) ? timeoutMs : DEFAULT_TOOL_TIMEOUT_MS;\n        let timer;\n\n        const timeoutPromise = new Promise((resolve) => {\n            timer = setTimeout(() => resolve({ timedOut: true }), ms);\n            // Avoid keeping Node alive for timeout timers.\n            if (timer && typeof timer.unref === 'function') timer.unref();\n        });\n\n        try {\n            const value = await Promise.race([\n                Promise.resolve().then(fn).then((v) => ({ timedOut: false, value: v })),\n                timeoutPromise,\n            ]);\n            return value;\n        } finally {\n            if (timer) clearTimeout(timer);\n        }\n    }\n\n    _recordToolFailure(toolName, fingerprintOrType, args) {\n        // Back-compat: callers may pass a prebuilt fingerprint string.\n        // Preferred: pass a short failure type + args, so we can build a stable fingerprint.\n        let fingerprint = fingerprintOrType;\n        let failureType = undefined;\n        if (args !== undefined && typeof fingerprintOrType === 'string') {\n            failureType = fingerprintOrType;\n            fingerprint = makeFailureFingerprint(toolName, fingerprintOrType, args);\n        }\n\n        const prev = this._toolFailureStreak.get(toolName);\n        if (prev && prev.fingerprint === fingerprint) {\n            this._toolFailureStreak.set(toolName, {\n                count: prev.count + 1,\n                fingerprint,\n                failureType: failureType || prev.failureType,\n            });\n        } else {\n            this._toolFailureStreak.set(toolName, { count: 1, fingerprint, failureType });\n        }\n    }\n\n    _clearToolFailure(toolName) {\n        this._toolFailureStreak.delete(toolName);\n    }\n\n    _withSelfHealHint(toolName, output) {\n        const state = this._toolFailureStreak.get(toolName);\n        if (!state || state.count < 2) return output;\n\n        const hardStop = state.count >= DEFAULT_LOOP_FINGERPRINT_THRESHOLD;\n\n        const adviceByType = {\n            timeout: 'This tool timed out repeatedly. Reduce scope/complexity, verify network/connectivity, or use an alternative tool.',\n            rate_limited: 'This tool is being rate limited. Wait before retrying, reduce call frequency, or consolidate requests.',\n            format_error: 'This tool returned a non-JSON-serializable output. Adjust parameters to return structured JSON, or check read_skill_documentation.',\n            environment_restriction: 'This tool appears blocked by the browser environment (CORS / same-origin policy or blocked network request). Do NOT retry the same call. Explain the limitation to the user and suggest running in Node.js, or using an explicitly configured proxy/alternative source.',\n        };\n\n        const baseAdvice = hardStop\n            ? [\n                'STOP: You have repeated the same failing tool call. You MUST change your approach.',\n                adviceByType[state.failureType] || 'Verify inputs and environment, then change approach.',\n                'Do not retry with the same parameters. Either adjust inputs materially, or switch tools. If unsure, use list_available_skills and read_skill_documentation.',\n            ].join(' ')\n            : [\n                'This tool has failed repeatedly. Change strategy instead of retrying the same call.',\n                adviceByType[state.failureType] || 'Verify inputs and environment first (e.g. for run_command: try \"pwd\" and \"ls\"; for file/path issues: confirm the path).',\n                'If unsure, use list_available_skills and read_skill_documentation to find an appropriate alternative.',\n            ].join(' ');\n\n        // Keep payload compact and structured.\n        if (output && typeof output === 'object' && !Array.isArray(output)) {\n            return {\n                ...output,\n                _self_heal: {\n                    repeatedFailures: state.count,\n                    failureType: state.failureType || null,\n                    intervention: hardStop ? 'hard_stop' : 'soft_hint',\n                    advice: baseAdvice,\n                },\n            };\n        }\n\n        return {\n            result: output,\n            _self_heal: {\n                repeatedFailures: state.count,\n                failureType: state.failureType || null,\n                intervention: hardStop ? 'hard_stop' : 'soft_hint',\n                advice: baseAdvice,\n            },\n        };\n    }\n}\n\r\n// Export specific classes\r\nmodule.exports = { Agent };\r\n"],
  "mappings": "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",
  "names": ["out", "EventEmitter"]
}
